---
title: "An Introduction to Data Analysis in R"
author: "Aditya Ranganath"
date: "12/31/2022"
output:
  html_document:
        toc: true
        toc_depth: 3
        toc_float: true
        number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=F, warning=F, message=F}
library(tidyverse)
library(wosr)
library(DT) 
```

# Introduction

# Preliminaries

In this preliminary section, we'll cover basic information that will help you to get started with RStudio.

## R and RStudio Installation

If you haven't already, please go ahead and install both the R and RStudio applications. R and RStudio must be installed separately; you should install R first, and then RStudio. The R application is a bare-bones computing environment that supports statistical computing using the R programming language; RStudio is a visually appealing, feature-rich, and user-friendly interface that allows users to interact with this environment in an intuitive way. Once you have both applications installed, you don't need to open up R and RStudio separately; you only need to open and interact with RStudio (which will run R in the background). 

The following subsections provide instructions on installing R and RStudio for the macOS and Windows operating systems. These instructions are taken from the "Setup" section of the Data Carpentry Course entitled [*R for Social Scientists*](https://datacarpentry.org/r-socialsci/setup.html). The Data Carpentry page also contains installation instructions for the Linux operating system; if you're a Linux user, please refer to that page for instructions. 

The Appendix to Garret Grolemund's book *Hands on Programming with R* also provides an [excellent overview of the R and RStudio installation process](https://rstudio-education.github.io/hopr/). 

### Windows Installation Instructions

+ Download R from the [CRAN website](https://cran.r-project.org/bin/windows/base/)
+ Run the ```.exe``` file that was just downloaded.
+ Go to the [RStudio download page](https://www.rstudio.com/products/rstudio/download/#download) and under *Installers* select the "Windows" option.
+ Double click the file to install RStudio
+ Open RStudio to make sure it works. 

### macOS Installation Instructions

+ Download R from the [CRAN website](https://cran.r-project.org/bin/macosx/)
+ Select the ```.pkg``` file for the latest R version.
+ Double click on the downloaded file to install R.
+ It is also a good idea to install [XQuartz](https://www.xquartz.org/), which some packages require.
+ Go to the [RStudio download page](https://www.rstudio.com/products/rstudio/download/#download), and under *Installers* select the "macOS" option.
+ Double click the file to install RStudio
+ Open RStudio to make sure it works. 

## The RStudio Interface 

Now that we've installed and opened up RStudio, let's familiarize ourselves with the RStudio interface. When we open up RStudio, we'll see a window that looks something like this:

```{r, echo=FALSE, results='asis', out.width='100%', fig.cap='The RStudio Interface', fig.alt='RStudio Interface Open on Desktop'}
knitr::include_graphics('pictures/rstudio_window_revised.png')
```

If your interface doesn't look exactly like this, it shouldn't be a problem; we would expect to see minor cosmetic differences in the appearance of the interface across operating systems and computers (based on how they're configured). However, you should see four distinct windows within the larger RStudio interface:

- The **top-left** window is known as the *Source* window. 
  - The *Source* window is where we can write our R scripts (including the code associated with this tutorial), and execute those scripts. We can also type in R code into the "Console" window (bottom-left window), but it is preferable to write our code in a script within the source window. That's because scripts can be saved (while code written into the console cannot); writing scripts therefore allows us to keep track of what we're doing, and facilitates the reproducibility of our work. Note that in some cases, we may not see a *Source* window when we first open RStudio. In that case, to start a new script, simply click the ```File``` button on the RStudio menu bar, scroll down to ```New File``` button, and then select ```R Script``` from the menu bar that opens up.
  - It's also worth noting that the outputs of certain functions will appear in the *Source* window. In the context of our tutorial, when we want to view our datasets, we will use the ```View()``` function, which will display the relevant data within a new tab in the *Source* window. 
- The **top-right** window is the *Environment/History* pane of the RStudio interface. 
  - The "Environment" tab of this window provides information on the datasets we've loaded into RStudio, as well as objects we have defined (we'll talk about objects more later in the tutorial). 
  -The "History" tab of the window provides a record of the R commands we've run in a given session. 
- The **bottom-right** window is the *Files/Plots/Packages/Help/Viewer* window. 
  - The "Files" tab displays our computer's directories and file structures and allows us to navigate through them without having to leave the R environment. 
  - The "Plots" tab is the tab where we can view any visualizations that we create. Within the "Plots" tab, make note of the "Zoom" button, which we can use to enlarge the display of our visualizations if they're too compressed in the "Plots" window. Also, note the "Export" button within the "Plots" tab (next to the "Zoom" button); we can use this button to export the displayed visualization to a .png or .jpeg file that can be used outside of RStudio. 
  - The "Packages" tab provides information on which packages have been installed, as well as which packages are currently loaded (more on packages in Sections 2.3 and 2.4 below)
  - The "Help" tab displays documentation for R packages and functions. If you want to know more about how a package or function work, we can simply type a "?" followed by the package or function's name (no space between the question mark and the name) and relevant information will be displayed within the "Help" tab. 
  - The "Viewer" tab displays HTML output. If we write code that generates an HTML file, we can view it within the "Viewer" tab.
- The **bottom-left** window is the *Console/Terminal/Jobs* window. 
  - The "Console" tab is where we can see our code execute when we run our scripts, as well as certain outputs produced by those scripts. In addition, if there are any error or warning messages, they will be printed to the "Console" tab. We can also type code directly into the console, but as we noted earlier, it is better practice to write our code in a script and then run it from there. 
  - The "Terminal", "Jobs" tabs  are not relevant for our workshop. We'll briefly provide an overview of "R Markdown" towards the end of the lesson. 
  
## Install Packages 

R is an open-source programming language for statistical computing that allows users to carry out a wide range of data analysis and visualization tasks (among other things). One of the big advantages of using R is that it has a very large user community among social scientists, statisticians, and digital humanists, who frequently publish R packages. One might think of packages as workbooks of sorts, which contain a well-integrated set of R functions, scripts, data, and documentation; these "workbooks" are designed to facilitate certain tasks or implement useful procedures. These packages are then shared with the broader R user community, and at this point, anyone who needs to accomplish the tasks to which the package addresses itself can use the package in the context of their own projects. The ability to use published packages considerably simplifies the work of applied data research using R; it means that we rarely have to write code entirely from scratch, and can build on the code that others have published in the form of packages. This allows applied researchers to focus on substantive problems, without having to get too bogged down in complicated programming tasks. 

In this workshop, we will use the following packages to carry out relevant data analysis and visualization tasks (please click the relevant link to learn more about a given package; note that the tidyverse is not a single package, but rather an entire suite of packages used for common data science and analysis tasks): 
+ [*tidyverse*](https://www.tidyverse.org): 
+ [*wosr*](https://cran.r-project.org/web/packages/wosr/wosr.pdf)

To install a package in R, we can use the ```install.packages()``` function. A function is essentially a programming construct that takes a specified input, runs this input (called an "argument") through a set of procedures, and returns an output. In the code block below, the name of the package we want to install (here, the *tidyverse* suite) is enclosed within quotation marks and placed within parentheses after printing ```install.packages``` Running the code below will effectively download the *tidyverse* suite of packages to our computer:

```{r, eval=FALSE}
# Installs "tm" package
install.packages("tidyverse")
```

To run this code in your own R session:

* First, copy the code from the codeblock above (you can copy the code to your clipboard by hovering over the top-right of the code-block and clicking the "copy" icon; you can also highlight the code and copy from the ```Edit``` menu of your browser). 
* Then, start a new R script within RStudio; if you want to keep a future record of your work, you may want to save this script to your computer (perhaps in the same folder to which you downloaded the tutorial data). We can save our scripts via the RStudio "File" menu.
* Paste the code into the script, highlight it, and click the "Run" button that is just above the *Source* window.
* Alternatively, instead of copying/pasting, you can manually type in the code from the codeblock into your script (manually typing in the code is slower, but often a better way to learn than copy/pasting). 
* After you've run the code, watch the code execute in the console, and look for a message confirming that the package has been successfully installed. 

Below, we can see how that line of code should look in your script, and how to run it:

```{r, echo=FALSE, results='asis', out.width='100%', fig.cap='Installing tidyverse in R Script'}
knitr::include_graphics('pictures/install2.png')
```

Please note that you can follow along with the tutorial on your own computers by transferring all of the subsequent codeblocks into your script in just this way. Run each codeblock in your RStudio environment as you go, and you should be able to replicate the entire tutorial on your computer. You can copy-paste the workshop code if you wish, but we recommend actually retyping the code into your script, since this will help you to more effectively familiarize yourself with the process of writing code in R.

Note that the codeblocks in the tutorial usually have a comment, prefaced by a hash ("#"). When writing code in R (or any other command-line interface) it is good practice to preface one's code with brief comments that describe what a block of code is doing. Writing these comments can allow someone else (or your future self) to read and quickly understand the code more easily than otherwise might be the case. The hash before the comment effectively tells R that the subsequent text is a comment, and should be ignored when running a script. If one does not preface the comment with a hash, R wouldn't know to ignore the comment, and would throw an error message.

Now, let's install the other packages we mentioned above, using the same ```install.packages()``` function: 

```{r, eval=F}
install.packages("wosr")
```

All of the packages we need are now installed!

## Load libraries

However, while our packages are installed, they are not yet ready to use. Before we can use our packages, we must load them into our environment. We can think of the process of loading installed packages into a current R environment as analogous to opening up an application on your phone or computer after it has been installed (even after an application has been installed, you can't use it until you open it!). To load (i.e. "open") an R package, we pass the name of the package we want to load as an argument to the ```library()``` function. For example, if we want to load our *tidyverse* packages into the current environment, we can type:


```{r, eval=F}
# Loads tidyverse packages into memory
library(tidyverse)
```

At this point, the full suite of the *tidyverse* suite's functionality is available for us to use. 

Now, let's go ahead and load the remainder of the packages that we'll need:

```{r, eval=F}
# loads remainder of required packages
library(wosr)
```

At this point, the packages are loaded and ready to go! One important thing to note regarding the installation and loading of packages is that we only have to install packages once; after a package is installed, there is no need to subsequently reinstall it. However, we must load the packages we need (using the ```library``` function) every time we open a new R session. In other words, if we were to close RStudio at this point and open it up later, we would **not** need to install these packages again, but **would** need to load the packages again.  

# Part 1: Foundations for Data Analysis in R

Before we can get a sense of how to work with data in R, it is important to familiarize ourselves with basic features of the R language's syntax, and the basic data structures that are used to store and process data. 

## R as a Calculator

At its most basic, R can be used as a calculator. For instance: 

```{r}
# calculates 2+2
2+2
```

```{r}
# calculates 65 to the power of 4
65^4
```

While this is a useful starting point, the possibility of assigning values to objects (or variables) considerably increases the scope of the operations we are able to carry out. We turn to object assignment in the next sub-section. 

## Object assignment and manipulation

The concept of object (or variable) assignment is a fundamental concept when working in a scripting environment; indeed, the ability to easily assign values to objects is what allows us to easily and intuitively manipulate and process our data in a programmatic setting. To better understand the mechanics of object assignment, consider the following:

```{r}
# assign value 5 to new object named x
x<-5
```

In the code above, we use R's assignment operator, ```<-```, to assign the value 5 to an object named ```x```. Now that an object named ```x``` has been created and assigned the value 5, printing ```x``` in our console (or printing ```x``` in our script and running it) will return the value that has been assigned to the ```x``` object, i.e. 5: 

```{r}
# prints value assigned to "x"
x
```

More generally, the process of assignment effectively equates the output created by the code on the right side of the assignment operator (```<-```) to an object with a name that is specified on the left side of the assignment operator. Whenever we want to look at the contents of an object (i.e. the output created by the code to the right side of the assignment operator), we simply print the name of the object in the R console (or print the name and run it within a script). 

Let's create another object, named ```y```, and assign it the value "12": 

```{r}
# assign value 12 to new object named y
y<-12
```

As we noted above, we can print the value that was assigned to ```y``` by printing its name:

```{r}
# prints value assigned to "y"
y
```

It's possible to use existing objects to assign values to new ones. For example, we can assign the sum of ```x``` and ```y``` to a new object that we'll name ```xy_sum```: 

```{r}
# creates a new object, named "xy_sum" whose value is the sum of "x" and "y"
xy_sum<-x+y
```

Now, let's print the contents of ```xy_sum```

```{r}
# prints contents of "xy_sum"
xy_sum
```

As expected, we see that the value assigned to ```xy_sum``` is "17" (i.e. the sum of the values assigned to ```x``` and ```y```). 

It is possible to change the value assigned to a given object. For example, let's say we want to change the value assigned to ```x``` from "5" to "8":

```{r}
# assign value of "8" to object named "x"
x<-8
```

We can now confirm that ```x``` is now associated with the value "8"

```{r}
# prints updated value of "x"
x
```

It's worth noting that updating the value assigned to ```x``` will not automatically update the value assigned to ```xy_sum``` (which, recall, is the sum of ```x``` and ```y```). If we print the value assigned to ```xy_sum```, note that it is still "17"): 

```{r}
xy_sum
```

In order for the value assigned to ```xy_sum``` to be updated with the new value of ```x```, we must run the assignment operation again:

```{r}
# assigns sum of "y" and newly updated value of "x" to "xy_sum" object
xy_sum<-x+y
```

Now, the value of ```xy_sum``` should reflect the updated value of ```x```, which we can confirm by printing the value of ```xy_sum```:

```{r}
# prints value of "xy_sum"
xy_sum
```

Note that the value assigned to ```xy_sum``` is now "20" (the sum of "8" and "12"), rather than "17" (the sum of "5" and "12").

While the examples above were very simple, we can assign virtually any R code, and by extension, the data structure(s) generated by that code (such as datasets, vectors, graphs/plots etc.) to an R object. When naming your objects, try to be descriptive, so that the name of the object signifies something about its corresponding value. 

Below, consider a simple example of an object, named ```our_location``` that has been assigned a non-numeric value. It's value is a string, or textual information:

```{r}
our_location<-"Boulder, CO"
```

We can print string that has been assigned to the ```location``` object by typing the name of the object in our console, or running it from our script:

```{r}
# prints value of "our_location" object
our_location
```

Note that generally speaking, you have a lot of flexibility in naming your R objects, but there are certain rules. For example, object names must start with a letter, and cannot contain any special symbols (they can only contain letters, numbers, underscores, and periods). Also, object names cannot contain multiple unconnected words; if you'd like to use multiple words or phrases, connect the discrete elements with an underscore (```_```), or use camel case (where different words are distinguished by beginning each discrete word begins with a capitalized letter). 

It is also worth emphasizing that object names are case sensitive; in order to print the value assigned to an object, that object's name must be printed *exactly* as it was created. For example, if we were to type ```our_Location```, we would get an error, since there is no ```our_Location``` object (only an ```our_location``` object):

```{r, error=TRUE}
our_Location
```

## Data structures

We now turn to a brief overview of some important data structures that help us to work with data in R. We will consider three data structures that are particularly useful: vectors, data frames, and lists. Note that this is not an exhaustive treatment of data structures in R; there are other structures, such as matrices and arrays, that are also important. However, we will limit our discussion to the data structures that are essential for getting started with data-based research in R. 

## Vectors

In R, a vector is a sequence of values. A vector is created using the ```c()``` function. For example, let's make a vector with some arbitrary numeric values:

```{r}
# makes vector with values 5,7,55,32
c(5, 7, 55, 32)
```

If we plan to work with this numeric vector again later in our workflow, it makes sense to assign it to an object, which we'll call ```arbitrary_values```:

```{r}
# assigns vector of arbitrary values to new object named "arbitrary_values"
arbitrary_values<-c(5,7,55.6,32.5)
```

Now, whenever we want to print the vector assigned to the ```arbitrary_values``` object, we can simply print the name of the object:

```{r}
# prints vector assigned to "arbitrary_values" object
arbitrary_values
```

It is possible to carry out mathematical operations with numeric vectors; for instance, let's say that we want to double the values in the ```arbitrary_values``` vector; to do so, we can simply multiply ```arbitrary_values``` by 2, which yields a new vector where each numeric element is twice the corresponding element in ```arbitrary_values```. Below, we'll create a new vector that doubles the values in ```arbitrary_values```, assign it to a new object named ```arbitrary_values_2x```, and print the contents of ```arbitrary_values_2x```:

```{r}
# creates a new vector that doubles the values in "arbitrary_values" and assigns it to a new object named 
"arbitrary_values_2x"
arbitrary_values_2x<-arbitrary_values*2

# prints contents of "arbitrary_values_2x"
arbitrary_values_2x
```

Now, let's say we want to add different vectors together; the code below creates a new vector by adding together ```arbitrary_values``` and ```arbitrary_values_2x```:

```{r}
arbitrary_values + arbitrary_values_2x
```

Note that each element of the resulting vector printed above is the sum of the corresponding elements in ```arbitrary_values``` and ```arbitrary_values_2x```.

Other arithmetic operations on numeric vectors are also possible, and you may wish to explore these on your own as an exercise. 

In many cases, it is useful to extract a specific element from a vector. Each element in a given vector is assigned an index number, starting with 1; that is, the first element in a vector is assigned an index value of 1, the second element of a vector is assigned an index value of 2, and so on. We can use these index values to extract our desired vector elements. In particular, we can specify the desired index within square brackets after printing the name of the vector object of interest. For example, let's say we want to extract the 3rd element of the vector in ```arbitrary_values```. We can do so with the following:

```{r}
# extracts third element of "arbitrary_values_2x" vector
arbitrary_values[3]
```

It is also possible to extract a range of values from a vector using index values. For example, let's say we want to extract a new vector comprised of the second, third, and fourth numeric elements in ```arbitrary_values```; we can do so with the following:

```{r}
# extracts a new vector comprised of the 2nd, 3rd, and 4th elements of the existing "arbitrary_values" vector
arbitrary_values[2:4]
```

Thus far, we have been working with numeric vectors, where each of the vector's elements is a numeric value, but it is also possible to create vectors in which the elements are strings (i.e. text). Such vectors are know as character vectors. For example, the code below creates a character vector of the first four months of the year, and assigns it to a new object named ```months_four```:

```{r}
# creates character vector whose elements are the first four months of the year, and assigns the vector to a new object named "months_four"
months_four<-c("January", "February", "March", "April")
```

Let's now print the character vector assigned to ```months_four```: 

```{r}
# prints contents of "months_four"
months_four
```

We can extract elements from character vectors using index values in the same way we did so for elements in a numeric vector. For example:

```{r}
# extracts second element of "months_four" object (i.e. the "February" string)
months_four[2]
```

```{r}
# subsets the second and third elements of "months_four" object (i.e. the "February" and "March" strings, which are extracted as a new character vector)
months_four[2:3]
```

## Data frames

The data frame structure is the workhorse of data analysis in R. A data frame resembles a table, of the sort you might generate in a spreadsheet application. 

Often, the most important (and arduous) step in a data analysis workflow is to assemble disparate strands of data into a tractable data frame. What does it mean for a data frame to be "tractable"? One way to define this concept more precisely is to appeal to the concept of "tidy" data, which is [often referenced in the data science world](https://vita.had.co.nz/papers/tidy-data.pdf). Broadly speaking, a "tidy" data frame is a table in which:

1. Each variable has its own column
2. Each observation has its own row
3. Each value has its own cell

We will work extensively with data frames later in the workshop, but let's generate a simple data frame from scratch, and assign it to a new object. We will generate a data frame containing "dummy" country-level data on basic economic, geographic, and demographic variables, and assign it to a new object named ```country_df```. The data frame is created through the use of the ```data.frame()``` function, which has already been programmed into R. Column names and the corresponding column values are passed to the ```data.frame()``` function in the manner below, and the function effectively binds these different columns together into a table:

```{r}
# Creates a dummy country-level data frame 
country_df<-data.frame(Country=c("Country A", "Country B", "Country C"),
                       GDP=c(8000, 30000, 23500),
                       Population=c(2000, 5400, 10000),
                       Continent=c("South America", "Europe", "North America"))
```

To observe the structure of the table, we can print it to the R console by simply printing the name of the object to which it has been assigned:

```{r}
# prints "country_df" data frame to console
country_df
```

One nice feature of R Studio is that instead of simply printing our data frames into the console, we can view a nicely formatted version of our data frame by passing the name of the data frame object through the ```View()``` function. For example, the code below will bring up the ```country_df``` data frame as a new tab in R Studio:

```{r}
# pulls up "country_df" data frame in R Studio data viewer
View(country_df)
```

```{r, echo=F}
country_df %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Note the "tidy" features of this simple data frame: 

1. Each of the variables (i.e. GDP, Population, Continent) has its own column
2. Each of the (country-level) observations has its own row
3. Each of the values (i.e. country-level information about a given variable) has its own distinct cell

We will explore data frames, and the process of extracting information from them, at greater length in subsequent sections. 

### Lists

In R, a list is a data structure that allows us to conveniently store a variety of different objects, of various types. For example, we can use a list to vectors, data frames, visualizations and graphs--basically any R object you can think of! It is also possible to store a list within a list. 

Lists allow us to keep track of the various objects we create, and are therefore a useful data management tool. In addition, lists are very helpful to use when we want to perform iterative operations across multiple objects. 

We can create lists in R using the ```list()``` function; the arguments to this function are the objects that we want to include in the list. In the code below, we'll create a list (assigned to an object named ```example_list```) that contains some of the objects we create earlier in the lesson: the ```arbitrary_values``` vector, the ```months_four``` vector, and the ```country_df``` data frame. 

```{r}
# creates list whose elements are the "arbitrary_values" numeric vector, the "months_four" character vector, and the "country_df" data frame, and assigns it to a new object named "example_list"
example_list<-list(arbitrary_values, months_four, country_df)
```

Now that we've created our list object, let's print out its contents:

```{r}
# prints contents of "example_list"
example_list
```

As you can see, our list contains each of the various specified objects within a single, unified structure. We can access specific elements within a list using the specific index number of the desired element, in much the same way we did for vectors. When extracting a single list element from a list, the convention is to enclose the index number of the desired list element in double square brackets. For example, if we want to extract the country-level data frame from ```example_list```, we can use the following:

```{r}
# extracts country-level data frame from "example_list"; the country-level data frame is the third element in "example_list"
example_list[[3]]
```

If we want to subset a list, and extract more than one list element as a separate list, we can do so by creating a vector of the index values of the desired elements, and enclosing it in single brackets after the name of the list object. For example, if we wanted to generate a new list that contained only the first and third elements of ```example_list``` (the numeric vector of arbitrary values and the data frame), we would use the following syntax:

```{r}
example_list[c(1,3)]
```

While list elements are not automatically named, we can name our list element using the ```names()``` function. The first step to define a character vector of desired names. We can specify any names we'd like but for the sake of illustration, let's say we want to name the first list element "element1", the second list element "element2", and the third list element "element3". Let's create a vector of our desired names, and assign it to an object named ```name_vector```:

```{r}
# creates a character vector of desired names for list elements, and assigns it to a new object named "name_vector"
name_vector<-c("element1", "element2", "element3")
```

Now, we'll assign these names in ```name_vector``` to the list elements in ```example_list``` with the following

```{r}
# assigns names from "name_vector" to list elements in "example_list"
names(example_list)<-name_vector
```

Let's now print the contents of ```example_list```:

```{r}
# prints contents of "example_list"
example_list
```

Note that the list elements now have names attached to them; the first character string in ```name_vector``` is assigned as the name of the first element in ```example_list```, the second character string in ```name_vector``` is assigned as the name of the second element in ```example_list```, and so on. 

Practically speaking, we can now extract list elements using the assigned names. For example, if we want to extract the data frame from ```example_list```, we could do so by its assigned name ("element3"), as follows:

```{r}
# Extracts the data frame from "example_list" by its assigned name
example_list[["element3"]]
```

Note that even after assigning names to list elements, you can still extract elements by their index value, if you would prefer to do so:

```{r}
# # Extracts the "element3" data frame from "example_list" by its index number
example_list[[3]]

```

### Identifying data structures

It is useful to be able to quickly identify the data structure of a given object. Indeed, one way that things can go wrong when processing or analyzing data in R is that a given function expects a certain type of data structure as an input, but encounters something else, which will cause the function to throw an error or perform unexpectedly. In such circumstances, it is especially useful to be able to quickly double-check the data structure of a given object. 

We can quickly ascertain this information by passing a given object as an argument to the ```class()``` function, which will provide information about the object's data structure.

For example, let's say we want to confirm that ```example_list``` is indeed a list:

```{r}
# print the data structure of the "example_list" object
class(example_list)
```

Let's take another example:

```{r}
# print the data structure of the "months_four" object
class(months_four)
```

Note that we can read "character", as "character vector". 

Similarly, we can read "numeric" as "numeric vector":

```{r}
# print the data structure of the "arbitrary_values" object
class(arbitrary_values)
```

## Functions



## Iteration

# Part 2: Applied Data Analysis

## Data Transfer Part 1: Reading in Data

### reading in a dataset from your disk

### reading in multiple datasets from your disk

### reading in a dataset from cloud storage

### extracting data from the web

setting working directory

## Numeric Data Processing, Manipulation, and Visualization

## Text Data Processing, Manipulation, and Visualization

## Automating Data Tasks

# R Tools for Reproducibility and Communication




